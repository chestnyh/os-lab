// Алгоритм WSClock.

// 1) В програмі є структура процесу. 
// В цій структурі вказується час роботи процесу (весь час в програмі вимірюється в кількості звернень до пам'яті) і розмір його адресного простору. 
// 2) Адресний простір задається таблицею сторінок (там кожний рядок це атрибути P, R, M і номер фіз. сторінки). 
// Спочатку жодна вірт. сторінка не відображена, всі біти P=0. 

// Потім плануєте коли необхідно створити новий процес. 
// Час планування теж вимірюється в кількості звернень до пам'яті. Потім процес потрапляє на обробку.
// Плануєте скільки раз він буде звертатися до пам'яті і спочатку рандомно визначаєте номер вірт. сторінки до якої буде звернення. 
// Кожна фіз. сторінка повинна мати структуру. Спочатку структури всіх фіз. сторінок знаходяться в списку вільних сторінок. 
// І коли процес звертається до сторінки, то перевіряється біт P, якщо P==0, то відбувається сторінковий промах і ядро шукає вільну фіз. сторінку. 
// Якщо вільні фіз сторінки закінчилися, то виконується алгоритм заміни сторінок і шукається неактивна фіз. сторінка. 
// Якщо фіз. сторінка зайнята, то в її структурі вказується в якій таблиці сторінок в якому рядку вона використовується. 
// Тому коли фіз. сторінка відбирається, то в відповідній таблиці сторінок біт P встановлюється в 0.
 
// Рандомний номер вірт. сторінки до якої звертається процес треба замінити на роботу з робочим набором. 
// На деяку кількість звертань генеруєте робочий набір (наприклад 5 сторінок).
// І 90% звертань берете рандомну сторінку з робочого набору, а 10% звернень це будь яка вірт. сторінка з таблиці сторінок процесу. 
// Розмір робочого набору впливає на кількість сторінкових промахів.

// В програмі мають бути такі структури чи класи (в залежності від мови програмування):

// Process
// PageTable
// PTE (page table entry, це атрибути в PageTable)
// MMU (перевіряє P і встановлює R і M при звертанні до пам'яті).
// kernel (відповідає за сторінкові промахи і алгоритм заміни сторінок).
// PhysPage (фіз. сторінка).

// В системі один процесор, тому кожний процес обробляється циклічно.

// Приклад значень:

// Час роботи процесу: 100-150 звертань
// Розмір вірт. адресного простору: 50-70 сторінок
// Розмір фіз. адресного простору: 150 сторінок
// Макс. кількість процесів: 5
// Час обробки процесу на процесорі (квант): 15 звертань
// Розмір робочого набору: 5-10 сторінок
// Заміна робочого набору: після 25 звернень до пам'яті.

// Коли процес завершує роботу, то всі його фіз. сторінки потрапляють в список
// вільних фіз. сторінок. Обмежте максимальну кількість процесів в системі.

const Process = require("./classes/process");
const PhysicalPage = require("./classes/physical-page");
const Kernel = require("./classes/kernel");
const PageTable = require("./classes/page-table");
const MemoryManagementUnit = require("./classes/memory-managemrnt-unit");
// utils
const randomInt = require("./utils/random-int");
const Logger = require("./utils/logger");

global.logger = new Logger({
    successLogsFile: "./success.log",
    errorLogsFile: "./error.log"
});

//Час роботи процесу: 100-150 звертань
const processMaxWorkTime = 100; //100-150 звертань
// Розмір вірт. адресного простору: 50-70 сторінок
// Розмір фіз. адресного простору: 150 сторінок
const physicalPageSize = 150;
// Макс. кількість процесів: 5
const maxProcessesAmount = 5;
// Час обробки процесу на процесорі (квант): 15 звертань
// Розмір робочого набору: 5-10 сторінок
// Заміна робочого набору: після 25 звернень до пам'яті. 

const kernel = new Kernel({
    pageTable: new PageTable(),
    managementMemoryUnit: new MemoryManagementUnit({
        phisicalPage: new PhysicalPage({
            size: physicalPageSize
        })
    }) 
});

//------------------- PhisicalPage -----------------------

const processes = [];

for(let i = 1; i <= maxProcessesAmount; i++){

    processes.push(new Process({
        id: i,
        maxWorkTime: randomInt(100,150),
        virtualAddressSpaceMaxSize: randomInt(50,70),
        kernel: kernel
    }));

}

// Fill data to processes
for(let i in processes){

    try{
        while(true){
            processes[i].setData(randomInt(1, 10000000000000));
        }
    }
    catch(error){
        console.log("Process filled");
    }

}


// Start processes random operations
for(let proc of processes){
    proc.start();
}
